\section{Future Plans}

Both platform have substantial margin for improvements. Based on our
experience the users feedback has been a key player during our development
and helped us to improve the product in ways that we were not expecting.

Regarding Package Inventory we can definitely say that the software
reached a certain level of maturity and stability and it is safe for
deployment in production. The following improvements have been planned but
not yet implemented:

\begin{itemize}

  \item \textbf{Communication between Flume and the ElasticSearch cluster}

  Right now Flume sends the metrics to the ElasticSearch cluster using
  ElasticSearchSink \cite{elasticSearchSink} when instead it would be
  better to use a different kind of transport like, for example, AvroSink
  \cite{avroSink}. This would avoid the dependency of the ElasticSearch
  libraries and improve the reliability of the service adding two
  a secondary buffers for metrics on the client and on the cluster.

  \item \textbf{Scheduled checks with alerting on large clusters}

  Since the monitoring action of Package Inventory needs to be done
  periodically it would be a good to integrate it with the current
  alarming system to provide notifications in case of errors. Periodical
  scans might identify problems before the users.

  \item \textbf{Extend the cli interface}

  The current Cli provides only some basic functionalities and can be
  extended to deliver a better experience for the user. As said in the
  previous sections, to deliver a better experience we need to let the
  user experiment with the current one and find out which operations are
  more common or more difficult to accomplish.

  \item \textbf{Write libraries for different programming languages}

  Package Inventory has been optimized for being used with the Cli but
  that is not the only way we want to interact with it: in fact it might
  be useful to build libraries to integrate it with the most common
  languages.

  \item \textbf{Replace Flume with a more lightweight solution}

  The idea of replacing Flume with a lighter alternative has been
  evaluated several times since Flume is Java-based and tends to be quite
  heavy on the machine when the number of logs increases. The candidate
  for substitution is Logstash but no timeline for replacement has been
  defined yet.

\end{itemize}

The Continuous Integration platform has a big margin for development and
also to improve stability. Unfortunately since the contract at CERN was
ending we were not able to make the whole procedure failure-proof even if
most of the issues were solved. More than that, we also wrote some
features to be implemented in the future:

\begin{itemize}

  \item \textbf{Automate deployment of packages}

  In the previous sections, for the sake of brevity, we intentionally did
  not describe the procedure that an RPM package has to make to end in
  production. The iter is quite similar to a CRM: the new package gets
  tested, passes a week in the QA repository and, after that, it gets
  moved to the production repository.

  This procedure is, as well, quite manual and prone to human mistakes and
  there has been some movement to automate it as well. The idea is to let
  the Continuous Integration platform support also packages in the future,
  letting the users away from such repetitive tasks.

  \item \textbf{Tests for hostgroups}

  In addition to tests for modules we also have the necessity to introduce
  tests for hostgroups to make sure that our configuration for a set of
  servers is working correctly. This means introducing new tests
  guaranteeing that the combination of modules that our servers uses are
  working well together and that the virtual machine is behaving
  correctly.

  \item \textbf{Module dependencies}

  Puppet modules have their dependencies and, of course, when we modify
  a module we want to be sure that all the modules that are depending on
  that do not have issues with the change. To accomplish this we had the
  idea of specifying an additional field in the configuration file of the
  module where we could write down all the modules that depend on the one
  we are editing. In this way we could instruct Jenkins to trigger the
  tests not only on the module that is subject to the change but also all
  its dependencies.

\end{itemize}
