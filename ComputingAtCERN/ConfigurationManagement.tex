\section{Configuration Management}

With the adoption of OpenStack, other technologies in CERN were 
re-evaluated in order to determine if they represented best practice or
if other alternatives were available. With the adoption of a virtualized
infrastructure, it was going to be important to scale configuration
management to the expected number of machines. It also remains the case
that OpenStack is a complex set of projects which require care in their
configuration. CERN choose a solution that would allow them to take
advantage of configuration code developed outside the organisation to
configure large numbers of machines, as well as OpenStack components.

\subsection{Configuration}

\subsubsection{Puppet}

Puppet \cite{PuppetWebsite} is an open-source configuration management
utility that allows service managers to describe the configuration of
their machines using its own declarative language. It supports Unix-like
and Windows servers.

The user describes the status of the machine and his resources in a file
called \textit{Puppet manifest}, using Puppet's declarative language or
Ruby DSL. Before applying the catalog to the machine it must be compiled
using the system's information: Facter \cite{FacterWebsite} retrieves from
the server all the information needed by Puppet to compile the
catalog.Using the informations provided by Facter, Puppet compiles the
catalog to create a system-specific manifest that will be applied against
the target system.

Puppet describes the status of the system using a custom declarative
language which can be applied directly on the system or distributed to the
clients using a client/server paradigm. Service managers can specify their
configuration without the need to write system-specific commands, since
the description they provide using the Puppet manifest is operating system
independent.

\subsubsection{Foreman}

Foreman \cite{ForemanWebsite} is a tool to manage the lifecycle and the
provisioning of machines. It provides an easy to use web interface to
browse Puppet reports and manage machine's settings.

From Foreman the user is able to create and manage new machines assigning
them to a specified hostgroup/environment. When Puppet runs on a hosts it
queries Foreman's ENC (External Node Classifier) \cite{WhatIsENC} to ask
informations about the machine and configures it accordingly, compiling
the Puppet code stored in Git. In this case Foreman, given the hostname of
a server, returns a list of informations of the machine.

\subsection{Other tools}

The two tools described previously are just a small part of an extremely
complex infrastructure that includes a large set of tools. In this section
we will briefly describe the most important ones.

Finding a way to organize and classify code is one of the most important
aspects when we are dealing with a big organization like CERN. This is why
every collaborative repository is managed using Git. \textbf{Git}
\cite{GitWebsite} is an open-source revision control system with support
for distributed non-linear workflows. Every Git working directory is
a complete repository with full history, independent of the network
access. In the latest years his popularity grew dramatically, mostly due
to his extreme elasticity, compatibility with existing protocols and
support for non-linear development.

Since the code organization is stored in Git we need a build server to run
the automated test and tasks that are typical of an Agile environment.
This heavy task is lifted by \textbf{Jenkins}, an open-source continuous
integration tool written in Java. It is a server-based system running in
a servlet container. It is integrated with most of the revision control
systems and the multitude of available plugins made its popularity grow
year by year. It is currently used by several open-source project to run
unit and functional tests on code written by contributors.

Git and Jenkins can help us to write and test software but when it comes
to deployment we need necessarily to use Koji to package and distribute
our software. \textbf{Koji} is an RPM-based build system; it provides
a flexible, secure and reproducible way to build software. In combination
with Git it provides a fast way to package and distribute software across
the servers. When a developer is ready to release a new version of his
software he can use Koji to build and tag it to the correct repository. In
this way at the next distro-sync all the machines will receive the
updates.

The last step to manage servers efficiently is being able to run commands
on a set of machines. This task is performed by \textbf{MCollective},
a framework for server orchestration: it allows user to run actions on
a multitude of hosts. It is used extensively when it is necessary to deal
with several machines at the same time: trigger a command on multiple
servers, get the status of a package or a service across a cluster, etc.
It is well integrated with Puppet and Foreman, allowing us to trigger
actions on specified hostgroups/environments directly from the command
line just specifying the parameters of the servers we want to query.

