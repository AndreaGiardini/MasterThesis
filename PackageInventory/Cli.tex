\section{Cli}

A Cli is provided to query the status of packages and hosts from the
user's machines. It uses PuppetDB and the Elasticsearch cluster to return
the results to the user. A Kibana dashboard is provided as well to
constantly show the incoming number of reports and the activity of Package
Inventory.

In particular the PuppetDb integration has been proved to be very
effective and useful since the final user is not forced to specify the
hostnames of all the servers. The Cli automatically looks up the specified
hostgroup, getting dynamically all the servers that are part of it and
using them as a part of the query.

\subsection{Functions}

\begin{itemize}
  \item \textbf{Compare two or more hosts or machines}

  PackageInventory allows us to compare two or more servers. We are able
  to query PuppetDB to get a list of hosts or we can specify directly the
  hostnames. For example, if we want to compare all the hosts on
  a specific hostgroup:
  
  \begin{lstlisting}[frame=single]
  pkginv -H 'bi/batch/gridworker/aishare/share'
            -e production
            compare
  
  Processing hosts with:
  
       - Hostgroup: bi/batch/gridworker/aishare/share
       - Environment: production
  \end{lstlisting}

  In this case PackageInventory will get the list of the packages
  installed in all the servers that are part of the
  \textit{bi/batch/gridworker/aishare/share} hostgroup and the
  \textit{production} environment. After that, it will compare those
  lists, highlighting the differences and grouping machines with different
  packages lists in different groups.

  An example of the output is reported below:

  \begin{lstlisting}[frame=single]
  +------------+------------+------------+
  |  Group 0   |  Group 1   |  Group 2   |
  +------------+------------+------------+
  | b6b3d71dfa | b6b1576a51 | b60ba703db |
  | b636f67ca8 | b604a66b3b | b6e493a1b6 |
  | b62b21e394 | b6c6f66a36 |            |
  | b65573753a | b67d439ea5 |            |
  | b6a09855b8 |            |            |
  | b6a2bb83c8 |            |            |
  | b67af0481a |            |            |
  | b64f0f53c1 |            |            |
  | b69b92afd1 |            |            |
  | b67f818ae3 |            |            |
  | b67cc79825 |            |            |
  | b622b1cfdc |            |            |
  +------------+------------+------------+
  \end{lstlisting}

  Every group of hosts have the same package configuration, this means
  that the hosts in group one and two are drifting from the original
  configuration (since we assume that the majority of the hosts are not
  drifting). Since PackageInventory found more than two groups of hosts
  the difference between all these groups are not displayed or the output
  would be too verbose. If we want to get the differences between those
  groups we can use the Cli to output the differences between two single
  servers:

  \begin{lstlisting}[frame=single]
  
  \$ pkginv -m 'b6b3d71dfa b6b1576a51' compare

  +--------------------+-------+------------+-------------+
  |       Package      | Field | b6b3d71dfa |  b6b1576a51 |
  +--------------------+-------+------------+-------------+
  |       httpd        |       |  Present   | Not present |
  |    httpd-tools     |       |  Present   | Not present |
  |      gridsite      |       |  Present   | Not present |
  |      mod_ssl       |       |  Present   | Not present |
  |     castor-lib     | epoch |   8.slc6   |    9.slc6   |
  | castor-rfio-client | epoch |   8.slc6   |    9.slc6   |
  |  castor-ns-client  | epoch |   8.slc6   |    9.slc6   |
  |    castor-devel    | epoch |   8.slc6   |    9.slc6   |
  +--------------------+-------+------------+-------------+
  
  \end{lstlisting}

  In this example we picked two servers that were part of the group zero
  (the correct configuration) and group one (drifting group). As we can
  see from the previous output there are four packages (\textit{httpd,
  httpd-tools, gridsite, mod\_ssl}) that are installed in the hosts of
  group zero and not in group one. Moreover the CASTOR \cite{castor}
  libraries are installed with different versions.

  \item \textbf{Package List}

  Some basic function have been implemented as well to, for example,
  retrieve the list of the packages currently installed in a server:

  \begin{lstlisting}[frame=single]
  pkginv -m 'b6b3d71dfa' list
  \end{lstlisting}
  
  Or get all the informations for a specific package in a selected
  server:
  
  \begin{lstlisting}[frame=single]
  pkginv -m 'b6b3d71dfa' status -p 'sssd-client'
  \end{lstlisting}
 
  Eventually we can also compare the installed versions of a package on
  several hosts. This is used especially when we suspect that a specific
  package is creating problems in the hostgroup.
  
  \begin{lstlisting}[frame=single]
  pkginv -H 'bi/batch/gridworker/aishare/share'
         -e qa
         status
         -p 'sssd-client'
  \end{lstlisting}

  In this last example we asked PackageInventory to report the version of
  the package \textit{sssd-client} in all the servers that are part of the
  hostgroup \textit{bi/batch/gridworker/aishare/share} and the environment
  \textit{qa}.
  
  \item \textbf{Package History}

  In some occasions we might be also interested to see all the actions
  that have been performed on a packages: when it has been installed, when
  it has been upgraded, downgraded or removed. Using the \textit{history}
  option of our Cli it is possible to print the history of a package and
  see all the events related to it.

  In the following example we can see how PackageInventory prints the
  history of the \textit{nss} package in the \textit{b6b3d71dfa} server:

  \begin{lstlisting}[frame=single,basicstyle=\tiny]

  pkginv -m 'b6b3d71dfa' history -p 'nss'

  +---------+---------+--------------+------------+---------------------+
  | Package | Version |    Epoch     |   Action   |      Timestamp      |
  +---------+---------+--------------+------------+---------------------+
  |   nss   |  3.19.1 | 3.el6_6.cern |  Installed | 2015-07-03T16:28:27 |
  |   nss   |  3.19.1 | 4.el6_6.cern |  Upgraded  | 2015-07-03T16:30:01 |
  |   nss   |  3.19.1 | 4.el6_6.cern |   Removed  | 2015-07-03T16:31:05 |
  +---------+---------+--------------+------------+---------------------+
  \end{lstlisting}

  The history of a package is tracked since the installation of
  PackageInventory, we were not able to retrieve events previous to the
  installation of the reporter.
 
  \item \textbf{Package Status}

  We can specify a package and an host to get the detailed informations
  about that packages in a specific server. Eventually we can add the flag
  \textit{--check-reboot} to know if the specific server rebooted after
  the installation or upgrade of the package (particularly useful with
  LSF).
 
  \begin{lstlisting}[frame=single,basicstyle=\tiny]
  pkginv --check-reboot -m 'b6b3d71dfa' status -p 'CERN-CC-LSF-glibc2.3-config-batch

  +-----------------------------------+---------+--------+-------------+
  |              Package              | Version | Epoch  | Hasrebooted |
  +-----------------------------------+---------+--------+-------------+
  | CERN-CC-LSF-glibc2.3-config-batch |  7.0.6  | 80.el6 |    False    |
  +-----------------------------------+---------+--------+-------------+
  \end{lstlisting} 

\end{itemize}

\subsection{Querying ElasticSearch}

The query language of ElasticSearch is substantially different from the
one we used to have with relational databases like MySQL\@. In fact
ElasticSearch does not have the concept of tables, keys or triggers,
instead it provides databases with different mappings. This means that
when a database is created is necessary to provide a description of the
metrics that we want to store in it.

Defining a correct mapping is extremely important when we are dealing with
ElasticSearch since the data will be stored and optimized for the type of
mapping that we defined. Changing the mapping of a database afterwards is
possible but, depending on the amount of data we already have, might be
extremely time-consuming since the database needs to re-index all the
metrics.

\subsection{Optimizations for large-scale queries}

ElasticSearch is supposed to scale well even with big time consuming
queries. However, since our cluster is relatively small and the amount of
data aggregated by PackageInventory can be quite large in some cases, we
had to find a way to optimize our queries.

The most time consuming query is the one that is used to compare a cluster
of servers, since it requires to aggregate on multiple fields. The initial
idea was to run a unique big query to retrieve the packages list from all
the hosts to be compared at the same time. This method ended up to be
impossible to use due to the size of the clusters that we have in the
datacentre: aggregating packages of thousands of hosts in a unique query
was crashing the cluster.

We approached the problem splitting the query in several sub-queries in
which we consider just a portion of the hosts at the same time.
PackageInventory is not configured to split the queries if the cluster to
compare includes less than twenty five hosts. If the cluster contains more
hosts than the limit then PackageInventory automatically splits the
queries to compare only twenty five hosts at the same time and runs
multiple queries to retrieve all the metrics that it needs. Using this
technique the database is not hammered with big queries but with a set of
smaller queries. The user's computer takes than takes the results and
process them internally, offloading the database as soon as possible.
